# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 키패드 누르기
주어진 이진 문자열 binaryString을 1이 될 때까지 이진 변환을 가할 때,
['이진 변환 횟수', '제거된 모든 0 개수']를 반환한다.

#### 1. 이해
- 주어진 것은 무엇인가? / 모르는 것은 무엇인가? / 자료는 무엇인가? / 조건은 무엇인가?
- 이진 문자열
- 이진 변환 과정
  - 문자열의 모든 0을 제거한다.
  - 1만 남아있는 문자열의 길이를 구해 2진수로 변환한다.
- 문자열이 1이 될 때까지 이진 변환 과정을 반복
- s의 길이는 1-150000
- s에는 1이 최소 1개 이상 포함되어 있음

#### 2. 계획
- 각 이진 변환의 결과를 담을 배열을 놓음
  이 배열의 길이가 '이진 변환 횟수'가 될 것임
  (초기값으로 처음에 주어지는 binaryString을 넣을 것이기 때문에 '최종 길이 - 1'이 이진 변환 횟수)
- 제거된 모든 0의 개수를 합산하기 위한 변수를 놓음
  (일단 let을 사용하고, const를 사용할 수 있을지는 천천히 생각을...)
- while (배열의 맨 마지막 원소 값이 1일 때까지)
  - 배열에서 맨 마지막 원소 값을 꺼내옴
  - 0을 제거한 숫자 = [...꺼내온 값].filter((숫자) => 숫자 === 1).join('')
  - 제거한 0의 개수 = 꺼내온 숫자의 길이 - 0을 제거한 숫자의 길이
  - 제거된 모든 0의 개수 += 제거한 0의 개수
  - 0을 제거한 숫자의 '길이'를 2진수로 변환해 배열에 push
- [(배열의 길이 - 1), (제거한 모든 0의 개수)]를 반환

#### 3. 실행
- 문제풀이 설계 시간: 18분
- 문제풀이 시간: 25분(9:30-9:45, 10:05-10:15)

#### 4. 반성
- 제거한 0의 개수를 카운트할 때 변수를 재할당하지 않는 불변성을 지키면서 풀 방법이 떠오르지 않아
  일단 재할당하는 방식으로 풀었음
- filter 과정에서 숫자가 '1'과 같은 number를 filter했어야 했는데, 1과 같은 number를
  filter하게 하는 실수가 있었음. 문자열을 destructuring할 때는 숫자도 문자 형태임을 기억하자.
