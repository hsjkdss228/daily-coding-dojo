# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 피로도

> 완전 탐색

- https://school.programmers.co.kr/learn/courses/30/lessons/87946
- 유저의 현재 피로도 energy,
  각 던전별 [최소 필요 피로도, 소모 피로도]가 담긴
  2차원 배열 dungeons가 매개변수로 주어질 때,
  유저가 탐험할 수 있는 최대 던전 수를 return한다.

#### 1. 이해

- 피로도: 0 및 자연수
- 최소 필요 피로도: 던전의 탐험을 시작하기 위해 필요한 피로도 크기
- 소모 피로도: 던전을 탐험한 후 소모되는 피로도
- energy: 1 이상 5000 이하의 자연수
- '최소 필요 피로도', '소모 피로도'는 모두 1 이상 1000 이하의 자연수
- dungeon의 개수는 1 이상 8 이하
- '최소 필요 피로도'는 '소모 피로도보다 크거나 같음'
- 서로 다른 던전의 [최소 필요 피로도, 소모 피로도]가 같을 수 있음

#### 2. 계획

- dungeon의 수가 적으므로 모든 던전을 비교하면서
  배열을 순회하는 것이 가능할 것 같다.

- 총 순회한 던전 개수를 확인한다.
- energy가 모든 던전의 최소 필요 피로도보다
  낮아지기 전까지 다음 동작을 반복한다.
    - 던전을 하나씩 확인하면서
    - 'energy < energyNeed'인 던전은 배열에서 제외시킨다.
    - 'energy - 각 던전의 energyConsuming' 값이 가장 큰
      (즉 던전의 energyConsuming이 가장 작은) 던전을 찾는다.
    - 찾았으면 총 순회한 던전 개수 +1, 해당 던전을 배열에서 제외시킨다.
- 모든 던전을 순회했거나, 더 이상 던전을 순회할 수 없으면 반복을 종료한다.
- 그때까지 순회한 모든 던전 개수가 정답

#### 3. 실행

- 문제 계획 시간: 기존에 만들어놓은 계획이 존재했음
- 문제 풀이 시간: 9:20-10:10 (풀이 실패)
- 오류 추적 시간: 10:30-10:45, 11:00-11:20

#### 4. 반성

- '현재 피로도 -= 찾은 던전의 소모 피로도'를 하지 않았다.
  해줬을 때 예시 케이스를 해결하지 못하는 것을 확인.
- 최소 필요 피로도가 가장 높은 곳부터 방문하는 게 이득인가?
  최소 필요 피로도를 만족하는 곳들 중 소모 피로도가 가장 낮은 곳부터 방문했더니,
  최소 필요 피로도를 만족하지 못하게 되서 때문에 방문할 수 없는 곳이
  현재 피로도가 충분했을 때는 방문할 수 있었던 곳이라는 문제가 발생.
- 아쉽게도 가장 높은 곳부터 방문하는 경우도 마찬가지였다.
- 접근법이 달라져야 할 것 같다.
  - 던전을 순회하는 그 시점에만 크기를 비교해서 결정하는 게 아니라,
    모든 경우의 수를 (방문하는 플로우 전체) 만들어놓고, 경우의 수들끼리 비교하는 게 맞는 것 같다.
  - ex. [1 -> 2 -> 3], [1 -> 3 -> 2], [2 -> 1 -> 3], ...
  - '순열'이라는 방식이 있다고 하는 것 같다.
  - 내일 (1/13) 다시 풀어보도록 하자.
