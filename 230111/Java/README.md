# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 피로도

> 완전 탐색

- https://school.programmers.co.kr/learn/courses/30/lessons/87946
- 유저의 현재 피로도 energy,
  각 던전별 [최소 필요 피로도, 소모 피로도]가 담긴
  2차원 배열 dungeons가 매개변수로 주어질 때,
  유저가 탐험할 수 있는 최대 던전 수를 return한다.

### 23.1.13

#### 1. 이해

- 피로도: 0 및 자연수
- 최소 필요 피로도: 던전의 탐험을 시작하기 위해 필요한 피로도 크기
- 소모 피로도: 던전을 탐험한 후 소모되는 피로도
- energy: 1 이상 5000 이하의 자연수
- '최소 필요 피로도', '소모 피로도'는 모두 1 이상 1000 이하의 자연수
- dungeon의 개수는 1 이상 8 이하
- '최소 필요 피로도'는 '소모 피로도보다 크거나 같음'
- 서로 다른 던전의 [최소 필요 피로도, 소모 피로도]가 같을 수 있음

#### 2. 계획

- dungeon의 수가 적으므로 모든 던전을 비교하면서
  배열을 순회하는 것이 가능할 것 같다.

- 총 순회한 던전 개수를 확인한다.
- energy가 모든 던전의 최소 필요 피로도보다
  낮아지기 전까지 다음 동작을 반복한다.
    - 던전을 하나씩 확인하면서
    - 'energy < energyNeed'인 던전은 배열에서 제외시킨다.
    - 'energy - 각 던전의 energyConsuming' 값이 가장 큰
      (즉 던전의 energyConsuming이 가장 작은) 던전을 찾는다.
    - 찾았으면 총 순회한 던전 개수 +1, 해당 던전을 배열에서 제외시킨다.
- 모든 던전을 순회했거나, 더 이상 던전을 순회할 수 없으면 반복을 종료한다.
- 그때까지 순회한 모든 던전 개수가 정답

#### 3. 실행

- 문제 계획 시간: 기존에 만들어놓은 계획이 존재했음
- 문제 풀이 시간: 9:20-10:10 (풀이 실패)
- 오류 추적 시간: 10:30-10:45, 11:00-11:20

#### 4. 반성

- '현재 피로도 -= 찾은 던전의 소모 피로도'를 하지 않았다.
  해줬을 때 예시 케이스를 해결하지 못하는 것을 확인.
- 최소 필요 피로도가 가장 높은 곳부터 방문하는 게 이득인가?
  최소 필요 피로도를 만족하는 곳들 중 소모 피로도가 가장 낮은 곳부터 방문했더니,
  최소 필요 피로도를 만족하지 못하게 되서 때문에 방문할 수 없는 곳이
  현재 피로도가 충분했을 때는 방문할 수 있었던 곳이라는 문제가 발생.
- 아쉽게도 가장 높은 곳부터 방문하는 경우도 마찬가지였다.
- 접근법이 달라져야 할 것 같다.
  - 던전을 순회하는 그 시점에만 크기를 비교해서 결정하는 게 아니라,
    모든 경우의 수를 (방문하는 플로우 전체) 만들어놓고, 경우의 수들끼리 비교하는 게 맞는 것 같다.
  - ex. [1 -> 2 -> 3], [1 -> 3 -> 2], [2 -> 1 -> 3], ...
  - 모든 경우의 수를 재귀로 따져 들어간다면 최소 필요 피로도를 초과하는 시점이 나올 텐데
    그때부터는 그 경로의 방문은 중단하면 되는 것 같다.
  - '순열'이라는 방식이 있다고 하는 것 같다.
  - 내일 (1/13) 다시 풀어보도록 하자.

### 23.1.14

#### 1. 계획

- 방문에 성공한 던전 개수를 놓는다.
- for (i = 0; i < 던전 개수; i += 1)
  - 더 이상 방문할 던전이 없을 때까지 방문하지 않은 던전을 방문한다.
  - '모든 경우의 수를 다' 고려할 것이다.
    방문할 던전이 최소 필요 피로도를 충족하지 못하면 그 탐색은 중단.
  - ~~하나의 경우의 수에서 던전 탐색을 모두 마쳤으면 방문에 성공한 던전 개수 += 1~~
- ~~도출된 모든 방문에 성공한 던전 개수가 정답~~
  - 던전을 방문할 때, 그때까지 방문한 던전의 최대 개수보다 방문 횟수가 크면 방문 횟수를 갱신
- 모든 경우의 수 확인을 마쳤을 때의 방문 횟수가 정답

#### 2. 실행

- 문제 계획 시간: 9:10-9:35
- 문제 풀이 시간
  - 재귀 방식으로 방문하는 모든 경우의 수 구현: 9:35-10:05, 10:15-10:30
  - 실제 풀이: 10:35-10:55

#### 3. 반성

- 방문 방식을 구체적으로 글로 써보고 싶었는데 정리가 잘 안 됬다.
  코드를 참고하거나 직접 작성하면서 이해가 갈 때 같이 글로 옮겨보자.
- 방문하는 모든 경우의 수는 구했지만,
  문제에서 요구하는 조건은 방문하는 모든 경우의 수가 아니라 방문 가능한 최대 던전 개수이다.
- 각 던전을 방문할 때마다 내가 방문한 개수를 하나 늘리고,
  전체 방문한 개수와 비교해서 내가 방문한 개수가 클 때 전체 방문한 개수를 갱신하는 방법으로 수정
