# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 뒤에 있는 큰 수 찾기

> 연습문제

- https://school.programmers.co.kr/learn/courses/30/lessons/154539
- 정수 배열 numbers가 주어질 때,
- 모든 원소들의 뒷 큰 수들을 차례로 담은 배열을 return한다.
- 이때 뒷 큰 수가 존재하지 않는 원소는 -1을 담는다.

### 23.4.19

#### 1. 이해

1. 주어진 조건은 무엇인가?
   1. 규칙
      - 뒷 큰 수란?
        - 배열에서 자신보다 뒤에 있는 숫자들 중
          자신보다 크면서 가장 가까이에 있는 수
   2. 제한사항
      - numbers의 길이: 4 이상 1,000,000 이하
      - numbers[i]의 크기: 1 이상 1,000,000 이하
   3. 추론
      - 뒷 큰 수가 없으면 -1을 return하는 경우도 있음.
        - 자신의 숫자부터 단순히 뒤의 숫자를 모두 탐색하는 방식을 적용하기에는
          주어진 수가 너무 많음
        - 그렇지만 뒤의 있는 수를 확인해야 뒷 큰 수인지 아닌지를 판별할 텐데?
        - 더 이상의 뒤를 안 찾아봐도 되는 경우를 판별해서
          찾아봐야 하는 경우의 수를 줄일 수 있기는 하다.

2. 내가 이용할 수 있는 것은 무엇인가?
   - 배열의 각 숫자
   - 해당 숫자의 배열 내 순번

3. 내가 모르는 건 무엇인가?
   - 뒷 큰 수가 언제 나올 것인지

#### 2. 계획

1. 첫 번째 풀이: 배열의 맨 뒤에서부터 뒷 큰 수 여부를 파악한다.
   - 정답 배열 정의: int[numbers.length]
   - 맨 뒤 수의 뒷 큰 수는 무조건 -1
   - 배열의 마지막 수 앞 수부터 0번째 index까지 반복: 기준 수
     - 참조하는 수의 index + 1부터 마지막 index까지 반복: 뒤에 있는 수
       - 해당 뒤에 있는 수가 기준 수보다 크면 해당 수를 기준 수의 뒷 큰 수로 지정
       - 해당 뒤에 있는 수가 기준 수보다 크지 않으면서, 자신의 기준 수가 -1이면
         기준 수의 뒷 큰 수도 -1
       - 그렇지 않으면 계속 뒤에 있는 수를 탐색
   - 생성된 배열을 정답으로 반환

2. 두 번째 풀이
   - 기준 수의 뒤에 있는 수가 기준 수보다 크지 않으면서
     기준 수의 앞에 있는 수가 기준 수보다 클 경우,
     기준 수의 뒷 큰 수는 기준 수의 뒤에 있는 수의 뒷 큰 수와 같은 수

#### 3. 실행

- 이해/계획: 11:15-11:30, 11:45-12:05
- 풀이: 12:05-12:20, 12:50-12:55
- 오류 추적: 12:55-13:20, 13:30-15:00

#### 4. 반성

- 같은 복잡도의 로직에서 예외를 추가해서 검사 횟수 줄이기
  - 마지막 4개의 테스트 케이스에서 시간 초과. 탐색 횟수를 더 줄이기 위한 예외를 고려해야 할 듯.
  - 어떤 기준 수가 자신의 뒤에 있는 수의 뒷 큰 수와 같을 수 있는 경우가 있을까?
  - 생각해보면, 어떤 기준 수가 자신의 뒤에 있는 수보다 크지 않으면서
    자신의 앞에 있는 수보다 작으면, 그 기준 수의 뒷 큰 수는 자신의 뒤에 있는 수와 같다.

- 로직의 복잡도 개선하기
  - 기준 수 앞, 뒤의 숫자랑만 비교하도록 로직을 개선
  - 시간 복잡도 문제는 해결되었으나 대부분의 테스트 케이스가 실패

- 앞, 뒤 숫자랑만 비교하는 로직을 다시 작성
  - [기준 수 < 바로 뒤 수]이면 [기준 수의 뒷 큰 수]는 바로 뒤 수
  - [기준 수 >= 바로 뒤 수]이면
    - 바로 뒤 수의 뒷 큰 수가 -1이었으면 뒤에는 더 작은 수밖에 없다는 것이므로
      [기준 수의 뒷 큰 수]도 -1
    - 바로 뒤 수의 뒷 큰 수로 어떤 수가 있으면
      - [기준 수 < 바로 뒤 수의 뒷 큰 수]이면 [기준 수의 뒷 큰 수]는 바로 뒤 수의 뒷 큰 수
      - 그렇지 않고 [기준 수 >= 바로 뒤 수의 뒷 큰 수]이면,
        이제는 바로 뒤 수하고 비교할 수 있는 경우의 수는 모두 찾은 것.
        하지만 바로 뒤 수 너머에 혹시라도 마지막으로 가장 컸던 수가 있는지 확인할 필요가 있음.
      - 이를 위해 각 수의 뒷 큰 수를 갱신할 때, 마지막으로 가장 컸던 수를 기억해야 함.
      - [기준 수 < 마지막으로 가장 컸던 수]이면 [기준 수의 뒷 큰 수]는 마지막으로 가장 컸던 수.
      - 이마저도 아닐 때, [기준 수의 뒷 큰 수]는 -1
  - 실패.
  - gg

### 23.4.20

#### 1. 계획

- 특정 수의 뒷 큰 수를 건너뛰어서 다른 뒷 큰 수가 존재하는지
  찾아보는 로직을 추가한다.
- 맨 처음에 각 기준 수 중 큰 수인 경우 넣어놓을 List를 정의한다.
- 기준 수가 기준 수 바로 앞 수보다 크면 List에 기준 수를 추가.
- 가장 가까운 수 너머의 뒷 큰 수를 탐색해야 하는 경우,
  List의 수들을 순차적으로 탐색하고,
  조건을 만족하는 뒷 큰 수를 찾으면 해당 수를 뒷 큰 수로 설정한다.
- 역시 실패.

#### 2. 실행

- 이해/계획: 10:30-10:35
- 풀이: 10:35-11:00
- 오류 추적 및 답안 분석: 11:00-12:30

#### 3. 반성

- 같은 문제를 푼 동료분의 답안을 분석했다.
- 분석하자면 뒷 큰 수 여부를 아직 체크하지 않은 index들을 Stack에 순서대로 넣어 놓고,
  수들을 앞에서부터 순차적으로 확인해나가면서 뒷 큰 수 여부를 결정했다.
- Stack에는 나중에 넣은 수가 먼저 도출되기 때문에 기준이 되는 수로부터 가까운 수에 대해 먼저 판별하고,
  판별하지 못한 숫자가 있다면 Stack에서 계속 꺼내면서 판별을 시도할 수 있다.
- 이 과정은 O(n)이 될 수 있는데, 순회하는 횟수가 배열을 최대 두 번 순회하는 정도이기 때문이다.
- 반면, 기존의 내 풀이는 수들을 위에서부터 순차적으로 확인하면서 뒷 큰 수 여부를 결정했다.
- 이 방식의 문제는, 아무리 큰 수를 확인하는 과정에서 생길 수 있는 중복 프로세스를 개선하더라도
  O(n^2)을 벗어날 수 없다는 데 있다.
- 앞에서부터 만들어나가는 O(n) 방식에서는 기준 수랑 가까운 수를 평가하면서 큰 수를 부여할 수 없으면
  그보다 멀리 있는 수들에 대해서는 평가를 하나마나이므로 그런 경우 그냥 넘어갈 수 있었다.
- 그러나 뒤에서부터 만들어나가는 O(n^2) 방식에서는
  멀리 있는 더 큰 수들이 정답이 될 수도 있기 때문에 모든 멀리 있는 수들의 목록을 반드시 확인해야 했고,
  이 과정에서 제거할 수 없는 중복 프로세스가 발생할 수밖에 없었다.
- '뒤에서부터 확인해야 한다'는 생각에 매몰되어 있어
  근본적인 한계를 벗어날 수 없는 상태에서 해결책을 찾으려 했던 문제가 있었던 것 같다.
  몇 번의 개선을 시도해도 문제가 해결되지 않는다는 것이 확인되면,
  '이 전제는 당연히 지켜져야 하겠지' 생각되는 것들에 대해서도 한 번쯤 의심해보고
  바꿔서 시도해 볼 필요가 있다고 생각된다.
