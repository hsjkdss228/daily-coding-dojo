
# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 압축
주어진 문자열을 LZW 압축 과정을 통해 압축한 뒤, 사용된 사전 색인 번호를 배열로 출력한다.

#### 1. 이해
- 주어진 것은 무엇인가? / 모르는 것은 무엇인가? / 자료는 무엇인가? / 조건은 무엇인가?
  - 압축 방식
    - 사전에 등록된 단어
      - 1 2 3 4 ... 24 25 26
      - A B C D ... X  Y  Z
    - 입력으로 KAKAO가 들어올 때
      - 첫 번째 글자 K부터 시작하는 사전에 존재하는 가장 긴 문자열 검사
        - K: 있음 >> 11 출력
        - KA: 없음 >> KA 등록 (27)
      - 두 번째 글자 A부터 시작하는 사전에 존재하는 가장 긴 문자열 검사
        - A: 있음 >> 1 출력
        - AK: 없음 >> AK 등록 (28)
      - 세 번째 글자 K부터 시작하는 사전에 존재하는 가장 긴 문자열 검사
        - KA: 있음 >> 27 출력
        - KAO: 없음 >> KAO 등록 (29)
      - 다섯 번째 글자 O부터 시작하는 사전에 존재하는 가장 긴 문자열 검사
        - O: 있음 >> 15 출력
      - 최종적으로 KAKAO는 'K' 'A' 'KA' 'O'의 4개의 색인 번호로 압축됨
      - 색인 번호 목록은 [11, 1, 27, 15]

#### 2. 계획
- 정답 배열을 정의
- Map을 정의하고 ('A', 1), ('B', 2), ('C', 3), ... , ('Z', 26) 순으로 Map에 add
- 문자열의 첫 글자 index부터 마지막 글자 index까지 반복
  - 부분 문자열의 시작 index부터 마지막 index까지 / 앞 글자들을 포함하는 문자가 Map에 없을 때까지 검사
  - 이때 앞 글자들을 포함하는 문자는 임시로 저장 (임시 배열을 하나 만들고 배열에 push)
    - 위의 예시 세 번째 글자 K가 들어오는 예시에서
    - K: 있음
    - KA: 있음
    - KAO: 없음
  - Map에 없는 문자열이 발견되면 임시 저장 배열의 마지막 문자열의 숫자를 Map에서 찾아 정답 배열에 push
  - 그리고 Map에 없는 문자열을 ('새 문자열', Map의 크기 + 1) 해서 Map에 add
- 다 되었으면 정답 배열을 반환

#### 3. 실행


#### 4. 반성
- 계획은 JavaScript에서 사용하려 했던 계획을 그대로 가져왔으나, 시간 제한 상 직접 풀지는 못했고 다른 사람의 풀이를 가져왔음
- 신기한 점은 해당 풀이 과정이 내 계획과 거의 유사했다는 점
- 마지막 단어에서 문제가 생기지 않도록 예외처리를 해주고 있는 부분이 있는가?
- JavaScript의 함수형 메서드보다는 일반적인 for문이 재할당으로 index를 처리하기는 좀 더 쉬운 것 같기도 하다.
- Java를 먼저 풀고, JavaScript의 함수형 메서드로 리팩터링하는 과정을 거치는 게 좋겠다.
