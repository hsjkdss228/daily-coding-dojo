
# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 뉴스 클러스터링
입력으로 들어오는 두 문자열의 자카드 유사도를 출력한다.

#### 1. 이해
- 모르는 것은 무엇인가?
  - 각 문자열의 다중집합
- 주어진 것은 무엇인가?
  - 두 개의 문자열
  - 각 문자열은 (1, 2), (2, 3), (3, 4), ... 이런 식으로 두 개씩 묶어 집합을 만들어야 함
- 자료는 무엇인가?
  - 문자열, 문자(문자열의 문자에 알파벳이 아닌 값이 들어갔는지 검사하기 위해 필요?)
- 조건은 무엇인가?
  - 문자열을 자르기 위한 조건
    - 대문자와 소문자의 차이는 무시 (ab나 AB나 같은 것으로 취급)
    - 두 개의 문자를 묶었을 때 공백, 숫자, 특수문자가 포함된 부분 문자열은 버림
  - 다중집합의 교집합, 합집합을 구성하는 방식
    - 두 집합의 교집합은 중복되는 값들의 개수 중 적은 쪽의 개수를 선택
    - 두 집합의 합집합은 중복되는 값들의 개수 중 많은 쪽의 개수를 선택
  - 최종 결과: Math.floor(도출된 자카드 유사도 * 65536)
    - 만약 교집합, 합집합이 모두 0이라면 도출된 자카드 유사도는 그냥 1로 사용

#### 2. 계획
1. 두 문자열을 잘라 각각 다중집합을 만든다.
   1. 전체 문자열을 toUpperCase로 대문자로 바꾼다.
   2. 문자열의 길이가 n이면 index 기준 (0, 1), (1, 2), (2, 3), ... , (n-2, n-1) 이런 식으로
     문자열이 잘라져서 ~~배열이 만들어져야 한다.~~
   3. 다중집합의 교집합과 합집합을 구하는 이슈가 있었다. 따라서 배열이 아니라 Map 자료구조를 사용한다.
   4. 문자열을 만들면 Key로 문자열을 세고, Value로 문자열의 개수를 Count한다.
   5. Key가 없으면 (문자열, 카운트) 쌍을 넣고, Key가 있으면 카운트를 꺼내와서 1 증가시킨 뒤 다시 넣는다.
   6. 반복을 i = 0부터 n-2까지 돌리면서 문자열을 만든다. 이때 두 문자열의 각 단어를 charAt했을 때  
     대문자가 아니면 잘라진 그 문자열들은 패스한다.
2. 두 다중집합의 교집합과 합집합을 구한다.
   1. 문자열의 중복이 허용되어야 하고, 어느 쪽에 그 문자열이 적은지, 그리고 많은지 알 수 있어야 한다.
   2. 교집합은 두 Map에서 둘 다 Key가 있는 경우, 적은 쪽의 value를 합산한다.
   3. 2중 for문을 돌면서 검증한다.
   4. 합집합은 두 Map에서 한쪽만 Key가 있어도 value를 합산하고, 만약 둘 다 있다면 많은 쪽의 value만 선택한다.
3. 자카드 유사도를 계산한다.

#### 3. 실행


#### 4. 반성

