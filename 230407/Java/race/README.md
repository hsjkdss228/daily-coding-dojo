# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 달리기 경주

> 연습문제

- https://school.programmers.co.kr/learn/courses/30/lessons/178871
- 선수들의 이름이 1등부터 현재 등수 순서대로 담긴 문자열 배열 players,
- 해설자들이 부른 이름이 담긴 문자열 배열 callings가 매개변수로 주어질 때,
- 경주가 끝났을 때 선수들의 이름을 1등부터 등수 순서대로 배열에 담아 return한다.

### 23.4.7

#### 1. 이해

1. 주어진 조건은 무엇인가?
   1. 규칙
      - 해설진들이 특정 선수의 이름을 부르는 것은
        특정 선수가 자기 바로 앞의 선수를 추월한 것
      - ex. [mumu, soe, poe] 순서대로 달리고 있을 때,
        해설진이 soe를 호명했다면 soe 선수는 mumu 선수를 추월한 것.
        그러면 이제 순서는 [soe, mumu, poe] 순으로 바뀜
   2. 제한사항
      - players의 길이: 5 이상 50,000 이하
        - players[i]의 길이: 3 이상 10 이하
        - players에는 중복된 값이 들어가있지는 않음
      - callings의 길이: 2 이상 1,000,000 이하
        - callings는 players의 원소들로만 이루어져 있음
        - 경주 진행중에 1등인 선수의 이름은 불리지 않음
   3. 추론
      - 특정 선수를 지명했을 때, 선수의 이름을 목록에서 O(n) 복잡도의 기법으로
        일일이 찾기에는 players의 숫자가 너무 많다.
        빠르게 찾을 수 있어야 한다.

2. 내가 이용할 수 있는 것은 무엇인가?
   - 선수의 이름
   - 선수가 경기를 처음 시작할 때의 순위

3. 내가 모르는 건 무엇인가?
   - 규칙 자체에 대한 파악은 모두 한 듯.

#### 2. 계획

##### 최초 풀이

1. Map 두 개를 정의하고 players를 순회하면서 초기화
   - 선수 이름이 key인 Map: Map<선수 이름, 선수 순위>
   - 선수 순위가 key인 Map: Map<선수 순위, 선수 이름>
2. callings를 순회하면서 두 개의 Map을 업데이트
   - 선수 이름이 key인 Map에서 호명된 선수의 순위를 찾음
   - 선수 순위가 key인 Map에서 1순위 앞의 선수를 찾음
   - 두 개의 Map에서 호명된 선수와 1순위 앞의 선수를 서로 자리바꿈
3. 선수 순위가 key인 Map으로부터 정답을 도출
   - stream을 돌면서 key의 오름차순으로 정렬하고,
     value만을 집계해 array로 변환시켜 정답으로 반환

#### 3. 실행

- 이해/계획: 13:55-14:20
- 풀이: 15:10-15:30

#### 4. 반성

- rankingAndPlayers의 values() 메서드로 반환되는 컬렉션을
  그대로 toArray(String[]::new)를 통해 정답으로 사용할 수 있었다.
  HashMap에 Key, Value 쌍이 삽입될 때 Key의 오름차순 크기로 삽입되었기 때문?
