# [두 큐 합 같게 만들기]

[두 큐 합 같게 만들기]: https://school.programmers.co.kr/learn/courses/30/lessons/118667

> 2022 KAKAO TECH INTERNSHIP

## 문제 이해

### 설명

- 길이가 같은 두 개의 Array로 주어짐
- 해당 Array는 Queue라고 가정.
  - Array의 앞에 있을수록 Queue에 가장 먼저 넣은 수.
- 두 Queue에 대해 '작업'을 통해 각 Queue의 원소의 합이 같아지는 작업 횟수를 반환.
  - 두 Queue의 합을 같게 할 수 없는 경우, -1을 반환

### 제한사항

- '한 번의 작업': 숫자 하나를 pop해서 insert하는 작업
  - pop: 배열의 가장 앞 숫자를 제외
  - insert: 배열의 가장 뒤에 숫자를 삽입

## 풀이

### 풀이 1

#### 아이디어

- 입출력 예시에 대해 직접 따라해보기

```text
3 2 7 2: 14
4 6 5 1: 16

3 2 7 2 4: 18
6 5 1: 12

2 7 2 4: 15
6 5 1 3: 15
```

```text
1 2 1 2: 6
1 10 1 2: 14

1 2 1 2 1: 7
10 1 2: 13

1 2 1 2 1 10: 17  
1 2: 3

2 1 2 1 10: 16
1 2 1: 4

1 2 1 10: 14
1 2 1 2: 6

2 1 10: 13
1 2 1 2 1: 7

1 10: 11
1 2 1 2 1 2: 9

10: 10
1 2 1 2 1 2 1: 10
```

#### 설계

1. 처음에 `두 Queue의 합`을 구한다.
2. `Queue의 길이 * 3`만큼 반복 (`작업 Count`로 사용할 수 있음)
   1. 합이 같은 경우, `작업 Count` 반환
   2. 합이 큰 쪽에서 작은 쪽으로 pop, insert하면서 `두 Queue의 합`을 갱신
3. 반복이 끝난 경우, `두 Queue의 합`이 같은 경우는 존재하지 않으므로 -1 반환

#### 결과

- 통과
- 수행 시간: 5ms 내외 - 100ms 내외 
- 메모리 사용량: 70MB 내외 - 150MB

## 회고

### 엣지 케이스

- 원래 설계했던 2번은 이랬음.

```text
`(Queue의 길이 * 2) - 1`만큼 반복 (`작업 Count`로 사용할 수 있음)
    -1이 포함되는 이유?
        한 쪽에 지나치게 큰 수 하나만 들어있는 경우,
        반대편의 모든 수를 합쳐도 다른 쪽 수 하나에 미달하는 경우가 있을 수 있음.
        그 경우에 반대쪽의 Queue에서 pop해서 Queue가 비어버리는 일을 방지하기 위함
```

```text
6000 2: 6002
3 27: 30

2: 2
3 27 6000: 6030

2 3: 5
27 6000: 6027

2 3 27: 32
6000: 6000
```

- 일단 이 경우는, 합 자체를 Queue에 들어있는 값을 그때그때 합해 계산하는 게 아닌, sumQueue 값으로 빼기 때문에 Queue가 비어있다고 해서 Exception이 발생할 염려는 없기 때문에 `-1`을 하지 않아도 됨.
- 오히려, **`Queue의 길이 * 3`만큼 더 반복해야 함.** 왜냐? 아래의 반례를 확인.

```text
11111: 5
11191: 13

11111111: 8
91: 10
3회

111111119: 17
1: 1
1회

9: 9
111111111: 9
8회

총 12회
```

- 해당 반례는 최악의 경우.
  - 한쪽 Queue의 값들이 반대쪽으로 모두 전달되었다가 (n에 근접한 횟수만큼 반복)
  - 전달받은 Queue에서 다시 전달한 Queue로 거의 모든 값들을 전달하는 케이스. (2n에 근접한 횟수만큼 반복)
- 즉, 반복 횟수가 2n과 3n 사이에서 형성될 수 있기 때문에 `작업 Count`가 3n만큼은 반복되어야 함.

### 반복문의 조건 검사를 반복문 외부 컬렉션의 크기를 기준으로 측정하면 위험!

```java
Queue<Integer> queue1 = toQueue(rawQueue1);

for (
    int count = 0;
    count < queue1.size() * 3;
    count += 1
) {
    // queue1에 요소를 삽입하거나 추출한다.
    // ...
}
```

- 위의 코드는 반복문 내에서 조건 검사에 활용하는 컬렉션 `queue1`이 조작될 때마다 조건의 값이 바뀔 위험성이 있음.
- 따라서 다음과 같이 초기에 지정해야 할 조건값을 별도의 상수로 고정해야 함.

```java
Queue<Integer> queue1 = toQueue(rawQueue1);

int queue1ElementsCount = queue1.size();
for (
    int count = 0;
    count < queue1ElementsCount * 3;
    count += 1
) {
    // queue1에 요소를 삽입하거나 추출한다.
    // ...
}
```
