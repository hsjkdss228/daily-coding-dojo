# 💡 How to solve it?

> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 소수 찾기

> 소수 찾기

- https://school.programmers.co.kr/learn/courses/30/lessons/12921

### 23.8.13

- 1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환한다.

#### 1차

##### 1. 이해

1. 주어진 조건은 무엇인가?
   1. 소수: 1과 자기 자신으로만 나누어지는 수 (1은 소수가 아님)

2. 내가 이용할 수 있는 것은 무엇인가?
   1. n: 입력받은 숫자 (정수)
      - n은 2 이상 1,000,000 이하의 자연수  

3. 내가 모르는 건 무엇인가?
   - 특정 수가 소수인지

##### 2. 계획

- 일단 특정 수가 소수가 아니라는 것은, 1과 자기자신 외에 자신을 나누어떨어지게 할 수 있는 수가 있다는 것이다.
- 가장 쉽게 생각할 수 있는 방법은 2부터 (자기자신 수 - 1)까지 1씩 더해가면서 그 수로 자신을 나누어보는 것
- 나누어떨어지면 그 수는 소수가 아닌 것이므로 1씩 더해가는 과정을 건너뜀

##### 3. 실행

- 이해/계획: 13:47-13:55
- 풀이: 13:55-14:10

##### 4. 반성

- n이 커질수록 매 반복에서 소수인지 아닌지 검증해야 하는 횟수도 자연스럽게 커지게 된다.
- 충분히 큰 수에 대해서는 반복을 최소화해야 할 필요가 있다.

#### 2차

##### 1. 이해

1. 내가 모르는 건 무엇인가?
   - 어떤 수를 판별하지 않아도 되는지

##### 2. 계획

1. 짝수는 반드시 소수가 아니다. 따라서 짝수는 연산에서 제외시킨다.
  - 단, 2는 소수이므로 2는 포함시킨다.

##### 3. 실행

- 이해/계획: 14:10-14:13
- 풀이: 14:13-14:16

##### 4. 반성

- 짝수를 계산하지 않을 경우 연산이 절반으로 줄어들지만, 대단히 큰 수가 주어지는 경우에 대해서는
  크게 감소 효과가 있지는 않았다.

#### 3차

##### 1. 이해

1. 내가 모르는 건 무엇인가?
   - 홀수인 수들 중에서 어떻게 소수인지 판별하는 연산 횟수를 감소시킬 수 있을 것인지

##### 2. 계획

1. 홀수는 홀수로 나눠야만 나누어떨어질 수 있는 가능성이 존재한다.
   - 짝수인 수를 걸러내므로, 나누는 수를 홀수로 한정짓는다.

##### 3. 실행

- 이해/계획: 14:16-14:20
- 풀이: 14:20-14:23

##### 4. 반성

- 시간초과 7개 케이스 중 한 개의 케이스가 추가로 통과했으나,
  8초가 소요되었음.

#### 4차

##### 1. 이해

1. 내가 모르는 건 무엇인가?
   - 충분히 큰 수에 대해 소수 판별을 위한 로직을 최소화할 수 있는 방법

##### 2. 계획

1. 이전의 결과를 특정 수에 대한 소수 판별에 활용할 수 있을까?
   - 소수 결과를 특정 컬렉션에 담는다: '소수 Set'
   - 홀수를 소수 컬력션에 있는 수들로 나누었을 때 나누어 떨어지는 경우 continue

##### 3. 실행

- 이해/계획: 14:23-14:40
- 풀이: 14:40-14:50

##### 4. 반성

- 1부터 n까지의 숫자들 사이에서도 모든 수를 다 확인할 필요가 없을 수 있을 것 같다.

#### 5차

##### 1. 이해

1. 내가 모르는 건 무엇인가?
   - 홀수 중에서 어떤 수만을 소수로 볼 것인지

##### 2. 계획

- 이전의 결과를 특정 수에 대한 소수 판별에 활용해 제외시켜본다.

1. 소수 판별에서 제외시킬 수를 담는 Set을 놓는다: '제외 Set'
2. 검사하는 홀수가 '제외 Set'에 존재하지 않는다면 '소수 Set'에 추가한다.
   1. 추가한 소수 자기자신을 계속 곱해서 나오는 수가 max보다 작으면 '제외 Set'에 추가
   2. '소수 Set'에 존재하는 각 소수 * 소수 자기자신의 결과가
      max보다 작으면 '제외 Set'에 추가

##### 3. 실행

- 이해/계획: 15:00-15:10
- 풀이: 15:10-15:18

##### 4. 반성

- 첫 문제를 제외한 모든 테스트 케이스가 오답...

#### 6차

##### 2. 계획

- '에라토스테네스의 체'를 풀이에 적용시킨다.
- https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4

##### 3. 실행

- 이해/계획: 15:55-16:00
- 풀이: 16:00-16:05
- 정확성 테스트 모두 통과 및 속도 개선 (최대 300ms)
- 효율성 테스트 4개 모두 실패

##### 4. 반성

- 컬렉션 대신 배열을 이용해본다.

#### 5차

##### 1. 이해

1. 내가 모르는 건 무엇인가?
   - 홀수 중에서 어떤 수만을 소수로 볼 것인지

##### 2. 계획

- 이전의 결과를 특정 수에 대한 소수 판별에 활용해 제외시켜본다.

1. 소수 판별에서 제외시킬 수를 담는 Set을 놓는다: '제외 Set'
2. 검사하는 홀수가 '제외 Set'에 존재하지 않는다면 '소수 Set'에 추가한다.
   1. 추가한 소수 자기자신을 계속 곱해서 나오는 수가 max보다 작으면 '제외 Set'에 추가
   2. '소수 Set'에 존재하는 각 소수 * 소수 자기자신의 결과가
      max보다 작으면 '제외 Set'에 추가

##### 3. 실행

- 이해/계획: 15:00-15:10
- 풀이: 15:10-15:18

##### 4. 반성

- 첫 문제를 제외한 모든 테스트 케이스가 오답...

#### 6차

##### 2. 계획

- '에라토스테네스의 체'를 풀이에 적용시킨다.
- https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4

##### 3. 실행

- 이해/계획: 15:55-16:00
- 풀이: 16:00-16:05
- 정확성 테스트 모두 통과 및 속도 개선 (최대 300ms)
- 효율성 테스트 4개 모두 실패

#### 6차

##### 2. 계획

- 컬렉션을 사용하는 대신 배열을 사용한다.

##### 3. 실행

- 이해/계획: 16:10-16:15
- 풀이: 16:15-16:27
- 통과

##### 4. 반성

- Collection을 활용하면 Wrapper 클래스의 크기 및 Wrapper 클래스를
  primitive 클래스로 변환해 연산하는 과정에서 연산 시간이 크게 증가하는 것 같다.
- 시간 복잡도 및 효율성을 요구하는 코딩 테스트는 가급적
  primitive 타입을 활용해 풀이해야 할 것 같다.
  
