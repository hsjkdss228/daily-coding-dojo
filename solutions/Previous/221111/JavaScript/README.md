
# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 압축
주어진 문자열을 LZW 압축 과정을 통해 압축한 뒤, 사용된 사전 색인 번호를 배열로 출력한다.

#### 1. 이해
- 주어진 것은 무엇인가? / 모르는 것은 무엇인가? / 자료는 무엇인가? / 조건은 무엇인가?
  - 압축 방식
    - 사전에 등록된 단어
      - 1 2 3 4 ... 24 25 26
      - A B C D ... X  Y  Z
    - 입력으로 KAKAO가 들어올 때
      - 첫 번째 글자 K부터 시작하는 사전에 존재하는 가장 긴 문자열 검사
        - K: 있음 >> 11 출력
        - KA: 없음 >> KA 등록 (27)
      - 두 번째 글자 A부터 시작하는 사전에 존재하는 가장 긴 문자열 검사
        - A: 있음 >> 1 출력
        - AK: 없음 >> AK 등록 (28)
      - 세 번째 글자 K부터 시작하는 사전에 존재하는 가장 긴 문자열 검사
        - KA: 있음 >> 27 출력
        - KAO: 없음 >> KAO 등록 (29)
      - 다섯 번째 글자 O부터 시작하는 사전에 존재하는 가장 긴 문자열 검사
        - O: 있음 >> 15 출력
      - 최종적으로 KAKAO는 'K' 'A' 'KA' 'O'의 4개의 색인 번호로 압축됨
      - 색인 번호 목록은 [11, 1, 27, 15]

#### 2. 계획
- 정답 배열을 정의
- Map을 정의하고 ('A', 1), ('B', 2), ('C', 3), ... , ('Z', 26) 순으로 Map에 add
- 문자열의 첫 글자 index부터 마지막 글자 index까지 반복
  - 부분 문자열의 시작 index부터 마지막 index까지 / 앞 글자들을 포함하는 문자가 Map에 없을 때까지 검사
  - 이때 앞 글자들을 포함하는 문자는 임시로 저장 (임시 배열을 하나 만들고 배열에 push)
    - 위의 예시 세 번째 글자 K가 들어오는 예시에서
    - K: 있음
    - KA: 있음
    - KAO: 없음
  - Map에 없는 문자열이 발견되면 임시 저장 배열의 마지막 문자열의 숫자를 Map에서 찾아 정답 배열에 push
  - 그리고 Map에 없는 문자열을 ('새 문자열', Map의 크기 + 1) 해서 Map에 add
- 다 되었으면 정답 배열을 반환

#### 3. 실행
- 두 글자 이상의 문자열이 있으면, 그 글자수만큼의 인덱스를 뛰어넘어야 하는 엣지 케이스가 있다.
  전체 문자열 반복을 forEach로 수행하는데, 어떻게 특정 반복을 건너뛰게 할까?
  >> forEach를 reduce로 바꿔서 사전에 문자열이 새로 추가된 경우
    그 횟수를 저장하도록 했다. 2개 이상의 문자열이 추가될 때에는
    '추가된 문자열 - 1' 만큼 reduce 반복을 건너뛰도록 했음
- 마지막 문자열을 탐색하는 케이스도 있었는데, 마지막 문자는 모든 알파벳 중에 하나가 있을 것이므로
  오류에 걸리지 않을 것임, 그래서 그냥 정답 배열에 push하도록 함

#### 4. 반성
- 마지막 예외 케이스를 넘지 못했다.
- 문자열이 단 하나의 알파벳이 아니라 사전에 새로 추가된 단어 묶음일 때, 어떻게 처리해줘야 할지 모르겠다.
- 순차적이 아닌 그때그때마다 변해야 하는 index를 함수형 메서드에서도 자유자재로 다룰 수 있는 방법은 없을까?
