
# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## N개의 최소공배수
n개의 숫자를 담은 배열 array가 입력되었을 때, 이 수들의 최소공배수를 반환한다.

#### 1. 이해
- 주어진 것은 무엇인가? / 모르는 것은 무엇인가? / 자료는 무엇인가? / 조건은 무엇인가?
- 최소공배수의 정의
  - n개의 수들의 배수 중 공통이 되는 가장 작은 숫자
- 자료형: 자연수

#### 2. 계획
- 이전에는 배열에서 두 개의 수를 꺼내 최소공배수를 구하고,
  다음 수와의 최소공배수를 구하는 방식을 반복해서 전체 최소공배수를 구했었음,
- 방식은 각자의 두 수를 두고, 상대방보다 자신이 작으면 자신에게 자기자신을 더하는데,
  두 수가 같아지면 그게 최소공배수였음
- ex. (6, 8) -> (12, 8) -> (12, 16) -> (18, 16) -> (18, 24) -> (24, 24)
  
- 이번에는 n개의 수의 최소공배수를 구하는 공식을 찾아 풀어볼 예정
- 지수를 이용해 최소공배수를 구할 수 있는 방식이 있었다.
  - 주어진 각자의 수를 소인수분해한다.
  - 소인수분해한 인자들끼리 공통되는 수가 있다면 지수가 큰 수를 가져온다.
  - 공통되지 않은 수가 있다면 모두 가져온다.
  - 가져온 수들을 모두 곱한다.
- 최소공배수: https://jwj4519.com/entry/%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98%EC%99%80-%EA%B3%B5%EB%B0%B0%EC%88%98-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98-%EA%B5%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95
- 소인수분해: https://st-lab.tistory.com/152

#### 3. 실행
- 소인수분해
  - 주어진 수를 1부터 sqrt(숫자)까지 1씩 더한 수로 나눴을 때 나머지가 0인지 확인한다.
  - 나머지가 0이면 인수 Map에 추가한다. (Key가 없으면 add, Key가 있으면 value + 1)
- 인수 확인
  - 각 Map에 있는 모든 Key 값들만 꺼내 중복되지 않는 Set으로 놓는다.
  - Set에 있는 값들을 Map이 가졌는지 검사한다.
    - 하나의 Map만 가졌다면 곱할 수 배열에 추가한다.
    - 2개 이상의 Map이 가졌다면 Map들 중에서 Value가 가장 큰 Map의 Key를 선택해
      Key * Value 값을 곱할 수 배열에 추가한다.
- 결과
  - 곱할 수 배열에 있는 모든 값들을 곱하면 정답  

- 1시간 안에 저걸 어떻게 다 구함?
- 두 수의 최소공배수를 구하는 공식인 유클리드 호제법을 이용하면 빠르게 풀 수 있다.
  - 두 수를 곱한 수를 최대공약수로 나눈다.
  - 최대공약수만 구하면, 최소공배수를 바로 구할 수 있다.
    - 두 수를 나누어 떨어질때까지 나누어서 최대공약수를 구한다.
  - 이런 식으로 구한 두 수의 최소공배수를 n개의 수만큼 반복한다.

#### 4. 반성
- 풀 수 있는 방법을 다른 곳을 참고해 빠르게 알아내는 것과 
  풀기 위해 고민하는 것 중에 어떤 것이 더 나은 선택인가.
