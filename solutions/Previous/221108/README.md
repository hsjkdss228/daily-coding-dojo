
# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 영어 끝말잇기
영단어 끝말잇기에 참가하는 참가자 수와 단어 배열이 주어질 때,
탈락자의 번호와, 탈락자가 몇 번째 차례인지 값의 쌍 배열을 반환한다.

#### 1. 이해
- 주어진 것은 무엇인가? / 모르는 것은 무엇인가? / 자료는 무엇인가? / 조건은 무엇인가?
  - 사용자 수, 단어의 개수 및 순서
  - 각 단어의 길이는 매번 다를 수 있음
  - 문자열과 개수
  - 문자열이 많이 주어져도 중간에 탈락자가 나올 수도 있음

#### 2. 계획
- 각 문자열에 대해 순차적으로 사용자 번호, 사용자 차례를 기억하면서
  - 단어가 이전에 나왔는지 확인한다.
  - 앞 단어 마지막 글자와 내 단어 첫 글자가 같은지 확인한다.
  - 하나라도 만족하지 못하면 사용자 번호, 사용자 차례의 쌍이 정답

- 외부에 확인한 문자열을 넣어놓기 위한 별도의 배열을 둔다.
- 주어지는 문자열 배열에 대해 reduce를 돈다.
- words의 길이가 100 이하이므로 끝까지 reduce를 돌아도 괜찮다.

- 정답 쌍은 (사용자 번호, 사용자가 돌던 차례)  

const 정답 쌍 = 단어 문자열.reduce((현재 정답 쌍, 배열에서 순서대로 꺼낸 문자열 word, 꺼낸 문자열의 index) => {  
  0. 정답 쌍이 (0, 0)이 아니면 return (continue와 같음)
  1. 확인한 문자열 array에 word가 이미 들어 있으면 정답 쌍을 바꿈  
  정답 쌍은 어떻게 알 수 있나?  
    - 배열을 탐색하고 있는 index의 순서와 참가자의 수를 알고 있다.  
    - 정답 쌍은 index/n을 했을 때 ((index%n)+1, Math.floor(index/n)+1)  
  2. 직전 문자의 끝 문자와 내 문자의 앞 문자가 같으면 정답 쌍을 바꿈
  3. 별도 배열에 탐색한 문자를 넣음
}, {참가자 번호: 0, 참가자가 차례를 돈 횟수: 0})

#### 3. 실행
- reduce의 accumulator를 object로 놓고, object가 바뀌도록 할 수는 없는 건가?  
  accumulator가 갖는 object를 바꾸도록 로직을 짰는데 안 바뀐다.

#### 4. 반성
- 아니다. 바뀐다. 테스트 코드에서 검증하는 배열을 이중으로 덮어씌우고 있어서
  문제를 맞게 풀었는데도 검증을 잘못 한 것이었다.
- 새 numberAndOrder를 만드는 로직이 중복되므로 공통 작업을 처리하는 함수로 뺼 수 있을 것이다.
