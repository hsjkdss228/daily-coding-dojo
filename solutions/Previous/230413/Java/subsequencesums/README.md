# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 연속 부분 수열 합의 개수

> 연습문제

- https://school.programmers.co.kr/learn/courses/30/lessons/131701
- 한 원형 수열을 구성하는 모든 원소를 순서대로 나타내는 배열 elements가 주어질 때,
  원형 수열에서 연속 부분 수열의 합으로 만들 수 있는 수의 개수를 return한다.

### 23.4.12

#### 1. 이해

1. 주어진 조건은 무엇인가?
   1. 규칙
      - 원형 수열이란?
        - 수열의 처음과 끝이 연결된 형태의 수열
        - 예를 들어 [1, 2, 3]이 일반적인 수열일 경우, 부분 수열은 다음과 같음
          - 원소가 1개인 부분 수열: [1], [2], [3]
          - 원소가 2개인 부분 수열: [1, 2], [2, 3]
          - 원소가 3개인 부분 수열: [1, 2, 3]
        - 그러나 원형 수열이라면 부분 수열은
          - 원소가 1개인 부분 수열: [1], [2], [3]
          - 원소가 2개인 부분 수열: [1, 2], [2, 3], [3, 1]
          - 원소가 3개인 부분 수열: [1, 2, 3], [2, 3, 1], [3, 1, 2]
   2. 제한사항
      - elements의 길이 (수열의 원소 개수): 3 이상 1,000 이하
      - elements[i]의 크기 (수열의 각 원소): 1 이상 1,000 이하
   3. 추론
      - 부분 수열을 구성하는 원소들이 달라도 합이 같은 경우는 있을 수 있다.

2. 내가 이용할 수 있는 것은 무엇인가?
   - 수열의 각 원소들

3. 내가 모르는 건 무엇인가?
   - 부분 수열의 합들 간에 얼마나 중복이 있을지
   - 모든 부분 수열의 합을 고려할 때 (모든 부분 수열의 길이의 모든 경우의 수를 다 따졌을 때)
     시간 초과가 날 것인지

#### 2. 계획

##### 최초 풀이

- 일단 모든 부분 수열로부터 도출할 수 있는 모든 합을 다 도출해본다.
- 수열 간 중복되는 원소가 많을 경우, 합을 구하지 않아도 될 것이다.
  따라서 부분 수열 자체가 중복되는 경우에도 합을 구하지 않고 넘어가도록 한다.

1. 객체 Subsequence 정의
   - 멤버
     - 요소들: Map<요소, 개수>
   - 생성자
     - 부분 수열을 순회하면서 Map에 요소와 개수를 알맞게 삽입
   - 합 method
     - Map의 요소와 개수들을 이용해 모든 합을 계산
   - equals
     - Subsequence 간에 같은 Map의 형태를 갖는지
   - hashCode
     - 일단 intelliJ에서 지정하는 기본 method를 사용하고,
       Set에서 contains를 제대로 식별하지 못할 경우 Map의 요소와 개수를 사용하는 것으로 수정
2. sums 정의: Set<합>
3. subsequences 정의: Set<Subsequence>
4. 1부터 수열의 길이만큼 반복 (부분 수열의 길이)
   - 생성할 수 있는 모든 부분 수열들을 생성
     - 시작 index를 수열의 index만큼 반복
     - 종료 index를 지정해 배열의 일부분을 분리.
       종료 index가 배열의 마지막 index를 넘어가는 경우
       넘어간 만큼의 index는 맨 처음부터 그 길이만큼 추가로 또 배열의 일부분을 분리하고
       두 배열을 합쳐 새 배열을 생성
     - 분리된 배열을 이용해 Subsequence 객체를 생성
     - 생성된 부분 수열이 subsequences에 없으면
       subsequences에 삽입하고, 합을 sums에 삽입
5. sums.size()를 정답으로 반환

#### 3. 실행

- 이해/계획: 10:45-11:20, 12:00-12:15 (50분)
- 풀이: 12:15-12:40, 14:00-14:30, 15:30-15:50 (75분)
- 오류 추적: 21:00-22:30 (90분)

#### 4. 반성

- 시간 초과도 발생하고, 메모리 초과도 발생한다.
  - 메모리 초과
    - elments의 크기가 1,000이라면 생성되는 Subsequence 인스턴스는 1,000,000개.
      생성되는 Map도 1,000,000개.
    - Subsequence 인스턴스에 전달되기 위해 복제된 배열도 1,000,000개
      \+ 인덱스가 분리될 경우 그 만큼의 배열도 같이 생성됨
    - Subsequence Set을 저장하지 않고 합만을 비교하는 것으로
      메모리 초과 및 일부 시간 초과 해결
  - 시간 초과
    - 모든 경우의 수를 봐야 하는 것은 어쩔 수 없지만
      배열을 만드는 효율성을 개선할 수는 있다.
    - 부분 수열 생성을 위해 새 배열에 데이터를 할당하는 것이 아닌
      기존 배열의 주소값을 참조하도록 하는 것을 시도
    - 실패

- DP 방식을 활용할 수 있다고 한다.
  - 부분 수열의 길이가 어떻게 되건, 각 길이에 따라 만들어지는 부분 수열의 개수는 동일하다.
  - 처음에 만드는 부분 수열을 계속해서 활용하는 식으로 수정해본다.
    - 길이 2의 부분 수열은 길이 1의 모든 부분 수열에서 그 다음 index의 요소를 더하고,
      길이 3의 부분 수열은 거기에 또 그 다음 index의 요소를 더하는 식
  - Map의 entrySet()을 모두 순회하면서 연산을 수행하는 데 상당히 많은 시간이 소요되었다.
    특정 index의 요소를 하나씩 더할 때 합계까지 같이 구하는 식으로 해결.
