# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 인사고과

- https://school.programmers.co.kr/learn/courses/30/lessons/152995
- 완호네 회사의 각 사원의 근무 태도 점수, 동료 평가 점수 목록의 쌍 배열 scores가 주어졌을 때,
  완호의 석차를 return한다.

### 23.1.30

#### 1. 이해

- scores
  - 2차원 배열
  - 길이: 1 이상 100,000 이하
  - 각 원소: 해당 사원의 [근무 태도 점수, 동료 평가 점수]
  - 근무 태도 점수, 동료 평가 점수는 모두 0 이상 100,000 이하
  - scores[0]: 완호의 점수
- 특정 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 1회 이상이면
  해당 사원은 석차에 들 수 없음
- 그렇지 않은 사원들은 두 점수의 합이 높은 순으로 석차를 계산
- 두 점수의 합이 동일한 사원이 있을 경우 동석차로 처리,
  동석차의 크기만큼 동석차의 다음 석차는 건너뜀
  (ex. 점수의 합이 가장 큰 사원이 2명 있을 경우, 1등이 2명이고, 그 다음 석차는 3등)
- 완호가 석차에 드는 기준을 충족하지 못하면 -1 return

#### 2. 계획

- 다른 사원보다 각 점수가 낮은지 확인하려면 일단 순회는 다 해야 할 것 같은데.
  - 총 배열을 순회하면서 원호의 각 점수와 다른 직원의 각 점수를 비교
  - 둘 다 낮은 경우가 있으면 -1 return
- List or LinkedHashMap?\<Integer or Entry\<사원 Index, 점수의 합\>\>를 놓고
- 배열을 각 쌍의 Value를 비교하면서 정렬한 뒤,
- Key가 0인 쌍이 List에서 어느 index인지 찾음
- 그 다음으로는 동석차가 존재하는지 찾음
  - 배열에서 같은 Value 값을 갖는 쌍의 개수를 찾고
  - "찾아낸 index - 같은 Value 값을 갖는 쌍의 개수" 결과를 정답으로 return

#### 3. 실행

- 문제 계획 시간: 15:15-15:30, 15:40-16:10
- 문제 풀이 시간: 16:00-16:40, 16:50-17:20

#### 4. 반성

- 이렇게 푸는 게 아닌 것 같다.
- 뭐가 문제인가?
  - 정렬과 동석차 계산 로직이 지나치게 복잡해진다.
  - 다른 동료들 중 석차에 들 수 없는 동료들이 발생하는 경우를 고려하지 않았다.
- 다른 정답의 접근법을 참고해보자.
