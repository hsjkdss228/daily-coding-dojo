# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 가장 큰 수

> 정렬

- https://school.programmers.co.kr/learn/courses/30/lessons/42746
- 0 또는 양의 정수들이 주어졌을 때, 정수를 이어붙여 만들 수 있는 모든 수들 중
  가장 큰 수를 문자열로 변환해 반환한다.

### 23.2.14

#### 1. 이해

- numbers의 길이는 1 이상 100,000 이하
- numbers의 원소는 0 이상 1000 이하
- ex
  - 주어진 정수가 [6, 10, 2]라면
  - ["6102", "6210", "1062", "1026", "2610", "2106"]를 만들 수 있음
  - 이 중 가장 큰 수는 "6210"

#### 2. 계획

- 숫자 결합은 문자열로 이루어져야 함
- 배열인 상태에서 미리 정렬시킨다.
  - 맨 앞자리가 크고, 숫자 길이가 짧을수록 앞으로 보낸다.
  - 같은 자리수의 숫자끼리는, 앞쪽 자리수가 같을 경우 뒤쪽 자리수가 큰 숫자를 앞으로 보낸다.
- 배열.join();

#### 3. 실행

- 문제 계획 시간: 20:40-21:10
- 문제 풀이 시간: 21:10-22:30 (오답)

#### 4. 반성

- 난관 1: compare 비교 알고리즘의 문제
  - https://school.programmers.co.kr/questions/21075 에서 제시된 반례에 따르면,
  - a와 b를 비교하다가 한쪽이 끝나면 바로 앞이나 맨 앞의 숫자를 추가해주는데,
    그러면 979와 97이 같아지고 67과 676 또는 67과 677등이 같아지는 경우가 생기는 문제가 발생할 수 있다.
  - 문자열 붙이기를 통해 (a + b)와 (b + a)를 비교해 어느 쪽이 더 큰지 가늠할 수 있다.
- 난관 2: Bubble Sort 방식으로 풀어서 시간 초과 발생 (O(n^2))
  - Quick Sort, Merge Sort 방식으로 풀어서 시간 복잡도를 줄여야 한다고 한다. (O(nlogn))

### 23.2.20

#### Quick Sort 서칭

- Quick Sort의 경우, pivot을 지정하고 pivot을 기준으로 좌우측의 요소들을
  pivot의 크기보다 작으면 왼쪽으로, pivot의 크기보다 크면 오른쪽으로 이동시키고,
  pivot을 기준으로 나뉜 좌우측의 배열을 다시 같은 방법으로 재귀적으로 정렬하는 방법이라고 한다.
- 문제는 개념만을 찾아본 채로 지금 풀고 있는 코딩도장 문제에 적용하기 어렵게 느껴졌다.
  구체적으로는 좌우측의 요소를 선정하는 기준을 정하는 게 어렵게 느껴졌다.
- 책을 보면서 Quick Sort와 Merge Sort를 수행하는 미니 프로젝트를 만들어본 뒤에,
  문제에 적용해보도록 하자.
  
