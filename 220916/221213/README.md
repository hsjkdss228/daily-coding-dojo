# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 키패드 누르기
- 각 번호가 주어질 때, 번호를 누를 엄지손가락이 왼쪽인지 오른쪽인지
  나타내는 연속된 문자열을 return한다.

#### 1. 이해
- 주어진 것은 무엇인가? / 모르는 것은 무엇인가? / 자료는 무엇인가? / 조건은 무엇인가?
- 왼쪽 엄지손가락(왼손)은 '*', 오른쪽 엄지손가락(오른손)은 '#' 위치에서 시작
- 왼쪽 열 숫자 '1, 4, 7'은 왼손을, 오른쪽 열 숫자 '3, 6, 9'는 무조건 오른손을 사용
- 가운데 열 '2, 5, 8, 0'은 두 손이 있는 위치에서 더 가까운 손을 사용
  - 만약 번호와 두 손의 거리가 같다면 오른손잡이는 오른손, 왼손잡이는 왼손을 사용

- 주어지는 번호 numbers 배열의 크기는 1-1000
- numbers 배열 원소는 0-9 사이의 정수
- 나타내야 하는 문자열은 L 또는 R이 연속되는 문자열

#### 2. 계획
- number가 2, 5, 8, 0일 때를 생각해야 하므로 현재 손가락의 위치를 알고 있어야 하겠음
- numbers.reduce
  - accumulator: { numbers: [], left: { x: 3, y: 0 }, right: { x: 2, y; 3 } }
  - number가 1, 4, 7이면 numbers에 +L, left 위치 갱신
  - number가 3, 6, 9이면 numbers에 +R, right 위치 갱신
  - number가 2, 5, 8, 0이면 2, 5, 8, 0의 위치와
    left, right의 거리를 계산해 크기를 비교
- reduce의 최종 결과 중 numbers를 반환

#### 3. 실행
* 15분 안에 문제 이해, 계획을 수립하고 구현에 들어가는 것을 시도 (실패)
  - 얼마나 초과? 1:25
- 풀이 시간 1시간 초과
  - 얼마나 초과? 30분

#### 4. 반성
- 테스트 13-20 실패
- 어떤 부분이 잘못되었을까?
  - '손가락을 상하좌우로만 이동할 수 있다' 조건을 고려하지 않았다.
  - 대각선으로 바로 이동하는 거리가 아닌, 직각으로 이동했을 때 나오는 거리를 비교해야 함
    - 유클리드 거리(대각선 이동 거리): sqrt(pow(abs(x2 - x1), 2) + pow(abs(y2 - y1), 2))
    - 맨해튼 이동 거리(직각 이동 거리): abs(x2 - x1) + abs(y2 - y1)
  - calculateLength를 맨해튼 이동 거리를 사용하는 것으로 수정
