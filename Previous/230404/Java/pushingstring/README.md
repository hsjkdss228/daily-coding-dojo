# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 문자열 밀기

> 코딩테스트 입문

- https://school.programmers.co.kr/learn/courses/30/lessons/120921
- 문자열 original와 target가 매개변수로 주어질 때,
- original를 오른쪽으로 한 칸씩 밀고 마지막 문자를 맨 앞으로 이동시켜서
- target를 만들 수 있는 최소 횟수를 return한다.
- target를 만들 수 없으면 -1을 return한다.

### 23.4.4

#### 1. 이해

1. 주어진 조건은 무엇인가?
   1. 규칙
      - 문자열은 오른쪽으로 밀어냄.
      - 예를 들어 "hello"를 오른쪽으로 한 칸 밀면 "ohell"이 되고,
        오른쪽으로 한 칸 더 밀면 "lohel"이 됨. 
   2. 제한사항
      - original의 길이와 target의 길이는 같고, 1 이상 99 이하
   3. 추론
      - 문자열을 규칙대로 계속해서 밀어내다 보면 결국에는 원래 문자열로 돌아오게 됨.
        그 안에 target 문자열이 나오는지를 확인할 수 있을 것.

2. 내가 이용할 수 있는 것은 무엇인가?
   - 변경되는 문자열
   - 변경한 횟수

3. 내가 모르는 건 무엇인가?
   - 일단 다 파악한 듯.

#### 2. 계획

##### 최초 풀이

1. 변경 횟수 정의: 0
2. 일단 두 문자열이 같으면, 변경 횟수를 그대로 return
3. 계속해서 변경시키는 문자열을 정의: changed
   - 일단 한 번 변경시킴
   - 변경 횟수 += 1
4. changed가 original과 같아질 때까지 반복
   - changed == target이면 변경 횟수를 return
   - 그렇지 않으면 변경시키고, 변경 횟수 += 1
5. while문을 벗어났으면, original 문자열은 target 문자열이 될 수 없으므로
   -1을 return

#### 3. 실행

- 이해/계획: 11:40-11:50
- 풀이: 11:50-12:05

#### 4. 반성

- string.repeat(반복 횟수)를 이용한 정말 멋있는 풀이가 있다.
- 목표 문자 "ohell"가 있을 때,
  original.repeat(2)를 통해 "ohellohell"를 만들 수 있다.
- 이제 만든 문자열.indexOf(원본 문자)를 이용해 문자가 시작되는 index를 찾으면
  그게 문자열을 한 칸씩 밀어서 문자열을 만든 횟수이다.
  없으면 만들 수 없으니까 -1을 반환한다.
