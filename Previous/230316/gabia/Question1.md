# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 문제 1

> gabia 2023년 상반기 백엔드개발 신입 채용

- 한 페이지에 표시되는 닉네임 수 userCountToShow,
  유저의 닉네임과 점수가 달성 순서대로 들어있는 배열 userScores가 매개변수로 주어질 때,
  랭킹 1페이지가 몇 번 바뀌는지 return한다.

#### 1. 이해

- 랭킹이 산정되는 규칙
  - 점수가 높으면 랭킹이 더 높음
  - 점수가 같다면 해당 점수를 먼저 달성한 유저의 랭킹이 더 높음
    (즉 기존 점수와 같은 점수가 들어온다면 같은 점수들 간에는 가장 마지막에 위치해야 함)
  - 어떤 유저가 자신의 이전 기록보다 더 높은 점수를 달성하면
    기존 기록을 삭제하고 새로운 기록으로 대체
  - 기존 기록보다 낮거나 같은 점수를 달성한 경우에는 무시
- 매개변수 조건
  - userCountToShow: 1 이상 100 이하
  - userScores의 길이: 1 이상 1000 이하
  - userScores의 각 원소: "닉네임 점수"
    - 닉네임의 길이: 1 이상 10 이하
    - 점수의 자리수: 1 이상 9 이하 (0으로 시작하지 않음)
  - userScores의 순서: 각 유저가 해당 점수를 달성한 순서

#### 2. 계획

- User 객체 정의
  - 요소: 닉네임 (String), 점수 (Integer)

- 랭킹 1페이지 정의: List<User>
- 랭킹 1페이지에 존재하는 유저 이름 목록 정의: ~~Map<User, 1페이지 내 Index>~~ Set<User>
  - Set에서 같을 조건: 닉네임이 같은지 여부로 판단

- userScore를 넣을 때마다 랭킹 1페이지의 모든 요소와 비교하면 시간 복잡도가 O(n^2)이 된다.
  userScores 크기가 1000까지긴 해서 최대 1,000,000번만 수행하기는 하는데...
- 랭킹 1페이지 꼴찌 유저 점수 값과 비교해서 그보다 낮으면
  비교 자체를 하지 않게 하는 방식으로 일단 해 보기

- 랭킹 페이지가 바뀐 횟수 정의 = 0
- 같은 유저의 기록을 바꿨는지 여부 체크 변수 정의 = false
- userScores.forEach(각 userScore에 대해)
  1. 랭킹 1페이지가 비어 있으면 조회하는 유저를 List와 Set에 add하고
     랭킹 페이지가 바뀐 횟수 += 1한 뒤 continue
  2. 조회하는 유저의 점수가 랭킹 페이지 내 마지막 유저의 점수보다 낮거나 같으면 continue
  3. 랭킹 1페이지에 조회하는 유저가 이미 있으면
     - 기존 기록보다 점수가 낮거나 같으면 continue
     - 기존 기록보다 점수가 높으면 List와 Set에서 해당 User를 remove
  4. 이제 List 내 요소들과 하나씩 비교
     - 특정 유저보다 크면 특정 유저 앞에 삽입하고 Set에도 삽입,
       랭킹 페이지가 바뀐 횟수 += 1
     - 맨 마지막 유저보다도 작거나 같지만, page.size < userCountToShow인 경우
       List의 맨 마지막과 Set에 각각 add
  5. List.size > userCountToShow인 경우
     - List에서 맨 마지막 요소를 제거하고, 해당 요소를 Set에서도 제거
- 랭킹 페이지가 바뀐 횟수를 정답으로 반환

#### 3. 실행

- 문제 계획 시간: 17:35-18:25
- 문제 풀이 시간: 18:25-20:10 (미해결)

### 4. 반성

- 놓친 예외
1. 새로운 user를 List에 넣을 때, Map에 있는 
   user들 중 user보다 뒤에 있는 user들의 index는 전부 1씩 증가되어야 함
   - 따라서 Map을 사용하지 않는 쪽으로 수정

2. '점수 변화가 있더라도 랭킹에 변화가 없다면 랭킹 페이지는 바뀌지 않는다'
   조건을 고려하지 않았음
   - 가장 빠르게 생각해낼 수 있는 방식으로는 현재는 기록의 유저 기록이 존재하는 경우
     해당 기록을 삭제하고 다시 삽입하는 방식이기 때문에,
     기존의 유저 기록이 존재하는 경우 해당 유저 기록의 index를
     별도로 기억하고 있다가, 유저 기록을 삽입하고 난 뒤 삽입된 위치의
     index와 기억하고 있는 index를 비교해 같은 경우에는
     랭킹 페이지가 바뀐 횟수를 변화시키지 않는 방식을 고려할 수 있겠음









