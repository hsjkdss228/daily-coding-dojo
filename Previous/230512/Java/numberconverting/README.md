# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 숫자 변환하기

> 연습문제

- https://school.programmers.co.kr/learn/courses/30/lessons/154538
- 자연수 x, y, n이 매개변수로 주어질 때,
- x를 y로 변환하기 위해 필요한 최소 연산 횟수를 return한다.
- x를 y로 변환할 수 없다면 -1을 return한다.

### 23.5.12

#### 1. 이해

1. 주어진 조건은 무엇인가?
   1. 규칙
      - x를 y로 변환하는 과정에서 사용할 수 있는 연산은?
        - x + n
        - x * 2
        - x * 3
   2. 제한사항
      - x, y는 자연수
      - x, y의 크기: 1 이상 1,000,000 이하
      - x는 y보다 작거나 같음
      - n의 크기: 1 이상 y 미만 (y보다는 반드시 작다.)
   3. 추론
      - 엣지 케이스
        - 연산 횟수가 0회인 경우도 있을 수 있음
        - x를 y로 만드는 것이 불가능할 수도 있음

2. 내가 이용할 수 있는 것은 무엇인가?
   - 계산 과정에 필요한 것들: x, n, 2, 3, 계산 중간에 바뀌는 x
   - 계산 결과: y

3. 내가 모르는 건 무엇인가?
   - 주어진 y가 x에서 연산을 통해 변환될 수 있는 가능성이 있는지
   - 각 한 번의 연산을 통해 해당 수에 얼마나 근접할 수 있는지

#### 2. 계획

1. 모든 경우의 수를 다 따질 수 있을까?
   - 재귀함수로 해결할 수 있을까?
   - 깊이 우선으로 파고 들어가면 안 된다. x가 1이고, y가 999999이고, n이 1인데
     n을 더하는 것을 먼저 고려하는 재귀함수라면 스택 오버플로우로 실패할 것이다.
   - 재귀함수로 들어가는 너비마다 나오는 결과를 고려할 수 있을까?

2. Queue 두 개를 써 보자.
   - 객체 정의 먼저.
     - Number
       - 필드
         - value: int, 현재 값
         - operationCount: int, 연산 횟수
       - 메서드
         - n 더하기
         - 2 곱하기
         - 3 곱하기
         - 정답인지
         - y보다 작은지
   - Queue 2개 정의.
   - 첫 번째 Queue에 주어진 값을 삽입
   - 무한 반복
     - 탈출 조건: 한 쪽 Queue에서 더 이상 꺼낼 값이 없을 때
     - 탈출했으면 -1을 return
     - 첫 번째 Queue에 있는 모든 값에 대해 반복
       - Queue에서 값을 완전히 꺼냄
       - 꺼내온 값에 n 더하기, 2 곱하기, 3 곱하기를 하면서
         count도 갱신한 새로운 객체 생성
       - 만든 객체가 y를 초과하면 없애버림
       - 만든 객체가 정답이면 count를 반환

#### 3. 실행

- 이해/계획: 12:40-12:50, 14:10-14:45
- 풀이: 14:55-15:15, 16:20-16:30
- 오류 추적: 16:30-17:10

#### 4. 반성

- 무한루프를 못 벗어나는 케이스가 존재하는 것 같다.
  - 풀이를 참고했을 때, 지금의 상향식 방식이 아닌
    하향식 방식으로 접근해볼 것을 추천하는 풀이가 있어 변경 시도
    - 더하기 -> 빼기
    - 곱하기 -> 해당 수로 나누어떨어질 경우 나누기
  - 성공
