# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 미로 탈출

> 연습문제

- https://school.programmers.co.kr/learn/courses/30/lessons/159993
- 미로를 나타낸 문자열 maps가 주어질 때,
  미로를 탈출하는 데 필요한 최소 시간을 return한다.
  탈출할 수 없다면 -1을 return한다.

### 23.3.1

#### 1. 이해

- 미로는 1*1 크기의 직사각형 격자 형태 (2차원 배열)
- 각 칸은 디음으로 구성
  - S: 시작 지점
  - E: 출구
  - L: 레버
  - O: 통로
  - X: 벽
- 한 칸을 이동하는 데 걸리는 시간은 1 
- 시작 지점에서 시작하면, 먼저 레버를 방문한 다음, 출구를 방문해야 함
- maps의 길이: 5 이상 100 이하
  - maps[i]의 길이: 5 이상 100 이하
  - 즉 미로의 크기는 최소 5\*5에서 최대 100\*100
- 시작 지점, 레버, 출구는 항상 다른 곳에 존재하며, 한 개씩만 존재
- 출구는 레버가 당겨지지 않아도 지나갈 수 있으며, 모든 통로, 출구, 레버, 시작점은 여러 번 지나갈 수 있음

#### 2. 계획

- 발생할 수 있는 예외 상황
  - 레버를 방문할 수 없는 경우
  - 출구를 방문할 수 없는 경우
- 재귀함수를 호출하는 방식으로 시작점 주변을 탐색하면서 레버와 출구를 찾기
- 필요한 값
  - 미로
  - 시작점 index
  - 목적지 index
  - 목적지 타입 (레버 혹은 출구)
  - 현재 블럭에 어느 방향으로부터 왔는지
  - Set\<유효한 총 이동 시간\>
  - (재귀함수 반복을 통해 계속 방문하는) 특정 경로의 총 이동 시간
  - 방문할 미로상의 index
- 재귀함수 로직
  - 방문한 지점이 벽이면 return
  - 방문한 지점이 목적지이면 Set\<이동 시간\>에 그때까지의 이동 시간을 add
  - 방문한 지점이 통로이면 총 이동 시간 += 1을 한 뒤,
    이전에 온 방향을 제외한 3방향에 대해 재귀함수를 호출
- 이동 거리가 더 적은 경로를 구분하는 방식
  - 재귀함수가 경로를 반환하게 하지 않고, Set\<유효한 총 이동 시간\>을 파라미터로 추가로 전달
  - 도착지점에 도착했을 때에는 Set\<이동 시간\>에 그때까지의 이동 시간을 add
  - 벽에 도달했으면 아무것도 하지 않고 동작 끝
- 전체 로직
  - 재귀함수를 호출해 시작점에서 레버까지의 거리를 계산
    - 계산된 거리가 -1이면 정답으로 -1을 return
  - 계산된 거리가 -1이 아니면 재귀함수를 호출해 레버에서 도착지까지의 거리를 계산
    - 계산된 거리가 -1이면 정답으로 -1을 return
  - 계산된 거리가 -1이 아니면 정답으로 시작점-레버, 레버-도착점 거리를 합산해 return

#### 3. 실행

- 문제 계획 시간: 15:20-15:55
- 문제 풀이 시간: 15:55-16:05, 16:25-17:55
- 오류 추적 시간: 17:55-20:00

#### 4. 반성

- 런타임 에러가 발생한 이유는?
  - 경로가 한 줄인 경우에는 문제가 없었지만, 두 줄 이상 열린 경로인 경우에는
    열린 경로 안에서 무한히 회전할 수 있어 무한반복의 우려가 있음?
  - 각 지점까지 갈 때, 1번 이상 방문한 경로인지 확인해
    1번 이상 방문한 경로인 경우에는 다시 되돌아가는 로직 추가
  - 런타임 에러는 발생하지 않으나, 특정 경로를 찾은 뒤 그 다음 경로를 탐색하려 할 때
    이전에 찾은 경로의 방문 기록이 남아 있어
    나머지 경로를 모두 탐색하지 않는 문제가 발생
  - 이를 해결하기 위해 한 가지 경로를 완성하면 경로 기록을 초기화시켜보려 했으나,
    이전과 마찬가지로 무한 루프 오류가 발생
  - 시간을 너무 많이 소요해 포기
