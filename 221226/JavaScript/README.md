# 💡 How to solve it?
> 문제를 풀기 전에 어떻게 풀 것인지 먼저 생각을 정리하고, 다 풀고 나서 회고한다.

## 과일 장수
과일 장수가 사과 상자를 팔았을 때 얻을 수 있는 최대 이익을 return한다.

#### 1. 이해
- 사과 한 상자의 가격을 결정하는 방식
  - 사과 하나의 점수는 1-k점까지의 점수로 분류: (1점: 최하품, k점: 최상품)
  - 사과 상자에는 numberInBox개의 사과를 담음
  - 사과 상자의 가격: 사과 상자에 담긴 사과 중 [가장 낮은 점수 * numberInBox]
- k의 범위: 3-9
- numberInBox의 범위: 3-10
- 사과들의 점수를 담은 배열(scores)의 길이: 7-1,000,000
- 각 사과의 점수(scores[i]): 1-k
- 이익이 발생하지 않는 경우에는 0을 return

#### 2. 계획
- 이익이 발생하지 않는 경우는 없다.
- scores를 내림차순으로 정렬한다: [최상품, 차상품, 차차상품, ... , 차하품, 최하품]
- 정답을 놓는다.
- scores에 대해 반복을 도는데, 한 상자에 담기는 사과에서 최하점수의 사과 가격만 확인하면 되므로
  i = 0; i < scores.length; i += numberInBox
- reduce 방식으로 합산한다면, ~~numberInBox % index === 1인 경우에만 scores를 accumulator에 합산한다.~~
  - ~~index < numberInBox인 경우에는 numberInBox % index === 1인 경우에,~~
    ~~index >= numberInBox인 경우에는 index % numberInBox === numberInBox - 1인 경우에~~
    ~~scores를 accumulator에 합산한다.~~
  - index % numberInBox === numberInBox - 1인 경우에만 scores를 accumulator에 합산한다.
- 정답을 return한다.

#### 3. 실행
- 문제 풀이 계획 시간: 9:25-9:45
- 문제 풀이 시간
  - JavaScript: 9:45-10:00, 10:10-10:40
  
#### 4. 반성
- 이익이 발생하지 않는 경우가 있었다.
  - 사과 상자에 들어가는 사과 개수가 주어진 사과 개수보다 많은 경우가 있다.
- 나머지 연산에 대해 착각하고 있는 부분이 있었다.
  - 피연산자가 연산자보다 작으면, 나머지 값은 피연산자가 그대로 됨
  - 즉 피연산자가 연산자보다 작은 경우, 큰 경우를 구분할 필요 없이
    피연산자를 값이 바뀌는 연산자로 나눴을 때 도출되는 나머지를 구하기만 하면 되는 것이었음
